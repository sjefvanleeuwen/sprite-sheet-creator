/**
 * SpriteSheetPlayer - A class for playing sprite sheet animations
 * Load and play animations from sprite sheets generated by the FBX Viewer
 */
class SpriteSheetPlayer {
    /**
     * Creates a new sprite sheet player
     * @param {Object} options - Configuration options
     * @param {string} options.canvasId - ID of the canvas element to draw on
     * @param {string} options.spriteSheet - Path to the sprite sheet image (optional)
     * @param {string} options.metadata - Path to the JSON metadata file (optional)
     * @param {number} options.fps - Frames per second for playback (default: 24)
     */
    constructor(options) {
        // Get canvas and context
        this.canvas = document.getElementById(options.canvasId);
        if (!this.canvas) {
            throw new Error(`Canvas element with ID '${options.canvasId}' not found`);
        }
        this.ctx = this.canvas.getContext('2d');
        
        // Initialize properties
        this.spriteSheet = null;
        this.metadata = null;
        this.currentFrame = 0;
        this.isPlaying = false;
        this.fps = options.fps || 24;
        this.lastFrameTime = 0;
        this.animationId = null;
        this.zoom = 1;
        this.onFrameChange = options.onFrameChange || null;
        this.onLoad = options.onLoad || null;
        this.onError = options.onError || null;
        
        // If sprite sheet and metadata paths are provided, load them
        if (options.spriteSheet && options.metadata) {
            this.load(options.spriteSheet, options.metadata);
        }
    }
    
    /**
     * Load a sprite sheet and its metadata
     * @param {string} spriteSheetPath - Path to the sprite sheet image
     * @param {string} metadataPath - Path to the metadata JSON file
     * @returns {Promise} - Promise that resolves when both files are loaded
     */
    load(spriteSheetPath, metadataPath) {
        return new Promise((resolve, reject) => {
            // Load metadata first
            fetch(metadataPath)
                .then(response => {
                    if (!response.ok) {
                        throw new Error(`Failed to load metadata: ${response.status} ${response.statusText}`);
                    }
                    return response.json();
                })
                .then(metadata => {
                    this.metadata = metadata;
                    
                    // Now load the sprite sheet image
                    this.spriteSheet = new Image();
                    this.spriteSheet.onload = () => {
                        this.resizeCanvas(
                            this.metadata.frameWidth * this.zoom,
                            this.metadata.frameHeight * this.zoom
                        );
                        this.drawFrame(0);
                        
                        // Call onLoad callback if provided
                        if (typeof this.onLoad === 'function') {
                            this.onLoad(this.metadata);
                        }
                        
                        resolve(this.metadata);
                    };
                    this.spriteSheet.onerror = (err) => {
                        const error = new Error(`Failed to load sprite sheet image: ${err.message}`);
                        if (typeof this.onError === 'function') {
                            this.onError(error);
                        }
                        reject(error);
                    };
                    this.spriteSheet.src = spriteSheetPath;
                })
                .catch(error => {
                    if (typeof this.onError === 'function') {
                        this.onError(error);
                    }
                    reject(error);
                });
        });
    }
    
    /**
     * Resize the canvas to match the frame size
     * @param {number} width - New width
     * @param {number} height - New height
     * @private
     */
    resizeCanvas(width, height) {
        this.canvas.width = width;
        this.canvas.height = height;
        this.ctx.clearRect(0, 0, width, height);
    }
    
    /**
     * Draw a specific frame from the sprite sheet
     * @param {number} frameIndex - Index of the frame to draw
     * @returns {boolean} - True if successful, false otherwise
     */
    drawFrame(frameIndex) {
        if (!this.spriteSheet || !this.metadata) return false;
        
        // Make sure frame index is within bounds
        this.currentFrame = frameIndex % this.metadata.frames;
        
        // Calculate the position in the sprite sheet
        const col = this.currentFrame % this.metadata.columns;
        const row = Math.floor(this.currentFrame / this.metadata.columns);
        
        const sourceX = col * this.metadata.frameWidth;
        const sourceY = row * this.metadata.frameHeight;
        
        // Clear the canvas
        this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
        
        // Draw the frame
        this.ctx.drawImage(
            this.spriteSheet,
            sourceX, sourceY, this.metadata.frameWidth, this.metadata.frameHeight,
            0, 0, this.canvas.width, this.canvas.height
        );
        
        // Call onFrameChange callback if provided
        if (typeof this.onFrameChange === 'function') {
            this.onFrameChange(this.currentFrame, this.metadata.frames);
        }
        
        return true;
    }
    
    /**
     * Start playing the animation
     * @returns {boolean} - True if started, false if already playing or no sprite sheet loaded
     */
    play() {
        if (this.isPlaying || !this.spriteSheet) return false;
        
        this.isPlaying = true;
        this.lastFrameTime = 0;
        this.animate();
        return true;
    }
    
    /**
     * Pause the animation
     * @returns {boolean} - True if paused, false if not playing
     */
    pause() {
        if (!this.isPlaying) return false;
        
        this.isPlaying = false;
        if (this.animationId) {
            cancelAnimationFrame(this.animationId);
        }
        return true;
    }
    
    /**
     * Animation loop
     * @param {number} timestamp - Current timestamp from requestAnimationFrame
     * @private
     */
    animate(timestamp) {
        if (!this.isPlaying) return;
        
        if (!this.lastFrameTime) this.lastFrameTime = timestamp;
        
        const elapsed = timestamp - this.lastFrameTime;
        const frameInterval = 1000 / this.fps;
        
        if (elapsed >= frameInterval) {
            // Move to next frame
            this.drawFrame(this.currentFrame + 1);
            this.lastFrameTime = timestamp;
        }
        
        this.animationId = requestAnimationFrame(this.animate.bind(this));
    }
    
    /**
     * Set the animation speed in frames per second
     * @param {number} fps - Frames per second
     */
    setFPS(fps) {
        this.fps = Math.max(1, fps);
    }
    
    /**
     * Set the zoom level
     * @param {number} zoom - Zoom level (1.0 = original size)
     */
    setZoom(zoom) {
        this.zoom = Math.max(0.1, zoom);
        
        if (this.metadata) {
            this.resizeCanvas(
                this.metadata.frameWidth * this.zoom,
                this.metadata.frameHeight * this.zoom
            );
            this.drawFrame(this.currentFrame);
        }
    }
    
    /**
     * Jump to a specific frame
     * @param {number} frameIndex - Index of the frame to jump to
     * @returns {boolean} - True if successful, false otherwise
     */
    goToFrame(frameIndex) {
        if (!this.spriteSheet || !this.metadata) return false;
        
        if (frameIndex >= 0 && frameIndex < this.metadata.frames) {
            return this.drawFrame(frameIndex);
        }
        return false;
    }
    
    /**
     * Get the total number of frames
     * @returns {number} - Number of frames, or 0 if no metadata is loaded
     */
    getTotalFrames() {
        return this.metadata ? this.metadata.frames : 0;
    }
    
    /**
     * Get the current frame index
     * @returns {number} - Current frame index
     */
    getCurrentFrame() {
        return this.currentFrame;
    }
    
    /**
     * Get the metadata
     * @returns {Object|null} - The metadata object, or null if not loaded
     */
    getMetadata() {
        return this.metadata;
    }
    
    /**
     * Check if the animation is currently playing
     * @returns {boolean} - True if playing, false otherwise
     */
    isAnimating() {
        return this.isPlaying;
    }
}

// Export for use in CommonJS, ES Modules, or global scope
if (typeof module !== 'undefined' && typeof module.exports !== 'undefined') {
    module.exports = SpriteSheetPlayer;
} else if (typeof define === 'function' && define.amd) {
    define([], function() {
        return SpriteSheetPlayer;
    });
} else {
    window.SpriteSheetPlayer = SpriteSheetPlayer;
}
